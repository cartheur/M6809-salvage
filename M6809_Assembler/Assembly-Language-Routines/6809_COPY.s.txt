;	Title:		Copy a Substring from a String 
;	Name:		COPY
;	Purpose:	Copy a substring from a string given a starting
;			index and the number of bytes.
;	Entry:
;			TOP 0F STACK 
;			High byte of return address
;			Low  byte of return address
;			Number of bytes to copy 
;			Starting index to copy from 
;			High byte of destination string address 
;			Low  byte of destination string address 
;			High byte of source string address
;			Low  byte of source string address 
;			Maximum Length of destination string
;
;			Each string consists of a Length byte
;			followed by a maximum of 255 characters.
;	Exit:
;			Destination string := The substring from the string. 
;
;			If no errors then Carry := 0
;			else
;				begin
;					 the following conditions cause an error
;					and the Carry flag = 1.
;					if (index = 0) or (maxlen = 0)
;					or (index > Length(source) 
;					then the destination string 
;					will have a zero length.
;					if (index + count 1) > Length(source))
;					then the destination string becomes
;					everything from index to the end of source string.
;				end
;	Registers Used:	ALL
;
;	Time:		Approximately (17 * count) cycles
;			plus 150 cycles overhead
;
;	Size:		Program	85 bytes
;
COPY:
	LDU	,S		; SAVE RETURN ADDRESS
	;
	; EXIT IF ZERO BYTES TO COPY,
	; ZERO MAXIMUM SUBSTRING LENGTH,
	; OR ZERO STARTING INDEX
	; LENGTH OF SUBSTRING IS ZERO IN ALL CASES
	;
	CLR	,S		; LENGTH OF SUBSTRING = 0
	LDA	2,S		; CHECK NUMBER OF BYTES TO COPY
	BEQ	OKEXIT		; BRANCH IF ZERO BYTES TO COPY, NO ERROR
				; SUBSTRING HILL JUST HAVE ZERO LENGTH
	LDA	8,S		; CHECK MAXIMUM LENGTH OF SUBSTRING
	BEQ	EREXIT		; TAKE ERROR EXIT IF SUBSTRING 
				; HAS ZERO MAXIMUM LENGTH
	LDA	3,S		; CHECK STARTING INDEX
	BEQ	EREXIT		; TAKE ERROR EXIT IF STARTING INDEX
				; IS ZERO (LENGTH BYTE)
	;
	; CHECK IF SOURCE STRING REACHES STARTING INDEX
	; TAKE ERROR EXIT IF IT DOESN'T
	;
	LDX	6,S		; GET ADDRESS OF SOURCE STRING
	CMPA	,X		; COMPARE STARTING INDEX TO LENGTH OF
				; SOURCE STRING
	BMI	EREXIT		; TAKE ERROR EXIT IF STARTING INDEX IS
				; TOO LARGE
	;
	; CHECK IF THERE ARE ENOUGH CHARACTERS IN SOURCE STRING
	; TO SATISFY THE NEED
	; THERE ARE IF STARTING INDEX + NUMBER OF BYTES TO COPY 1
	; IS LESS THAN OR EQUAL TO THE LENGTH OF THE SOURCE
	; STRING
	;
	CLR	1,S		; INDICATE NO TRUNCATION NEEDED
	LDB	2,S		; COUNT = NUMBER OF BYTES TO COPY
	ADDA	2,S		; ADD COUNT TO STARTING INDEX
	BCS	REDLEN
		BRANCH		; IF SUM IS GREATER THAN 255
	DECA			; CALCULATE INDEX OF LAST BYTE IN AREA
				; SPECIFIED FOR COPYING
	CMPA	,X		; COMPARE TO LENGTH OF SOURCE STRING
	BLS	CHKMAX		; BRANCH IF SOURCE STRING IS LONGER
	;
	; CALLER ASKED FOR TOO MANY CHARACTERS
	; JUST RETURN EVERYTHING BETWEEN STARTING INDEX AND THE END OF
	; THE SOURCE STRING
	; COUNT LENGTH(SSTRG) STARTING INDEX + 1
	; INDICATE TRUNCATION OF COUNT
	;
REDLEN:
	LDB	,X		; GET LENGTH OF SOURCE STRING
	SUBB	3,S		; COUNT = LENGTH STARTING INDEX + 1 INCB
	COM	1,S		; INDICATE TRUNCATION OF COUNT BY
				; SETTING MARKER TO FF
	;
	; DETERMINE IF THERE IS ENOUGH ROOM IN THE SUBSTRING
	; CHECK IF COUNT IS LESS THAN OR EQUAL TO MAXIMUM LENGTH
	; OF DESTINATION STRING. IF NOT, SET COUNT TO
	; MAXIMUM LENGTH
	; IF COUNT > MAXLEN THEN COUNT := MAXLEN
	;
	;
CHKMAX:
	CMPB	8,S		; COMPARE COUNT TO MAXIMUM SUBSTRING LENGTH
	BLS MOVSTR		; BRANCH (NO PROBLEM) IF COUNT IS LESS
				; THAN OR EQUAL TO MAXIMUM
	LDB	8,S		; OTHERWISE, REPLACE COUNT WITH MAXIMUM
	;
	; MOVE SUBSTRING TO DESTINATION STRING
	;
			
MOVSTR:
	STB	,S		; SAVE COUNT (LENGTH OF SUBSTRING)
	LDA	3,S		; GET STARTING INDEX
	LEAX	A,X		; POINT TO FIRST CHARACTER IN SOURCE STRING 
	LDY	4,S		; POINT TO BASE OF DESTINATION STRING 
	LEAY	1,Y		; POINT TO FIRST CHARACTER IN SUBSTRING 
MVLP:
	LDA	,X+		; GET BYTE FROM SOURCE STRING
	STA	,Y+		; MOVE BYTE TO DESTINATION STRING
	DECB			; CONTINUE THROUGH SPECIFIED NUMBER OF
	BNE	MVLP		; BYTES (COUNT)
	ROL	1,S		; MAKE CARRY INDICATE WHETHER REQUEST WAS
				; FULLY SATISFIED (1 IF IT WAS, 0 IF NOT)
	BCS	EREXIT
	;
	; MAKE CARRY INDICATE WHETHER ERRORS OCCURRED
	; 0 IF NOT, 1 IF THEY DID
	;
OKEXIT:
	CLC			; CLEAR CARRY, GOOD EXIT
	BRA	EXITCP
EREXIT:
	SEC			; SET CARRY, ERROR EXIT
	;
	; SET LENGTH OF SUBSTRING (COUNT)
	;
EXITCP:
	LDA	,S		; GET SUBSTRING LENGTH
	STA	[4,S]		; SAVE LENGTH IN SUBSTRING'S LENGTH BYTE
	;
	;
	; REMOVE PARAMETERS FROM STACK AND EXIT
	;
	LEAS	9,S	; REMOVE PARAMETERS FROM STACK
	JMP	,U	; EXIT TO RETURN ADDRESS
;
; SAMPLE EXECUTION:
;
SC5D:
	LDA	MXLEN		; MAXIMUM LENGTH OF SUBSTRING
	PSHS	A		; SAVE MAXIMUM LENGTH IN STACK
	LDY	#SSTG		; BASE ADDRESS OF SOURCE STRING
	LDX	#DSTG		; BASE ADDRESS OF DESTINATION STRING
	LDB	IDX		; STARTING INDEX TO COPY FROM
	LDA	CNT		; NUMBER OF BYTES TO COPY
	PSHS	A,B,X,Y		; SAVE PARAMETERS IN STACK
	JSR	COPY		; COPY SUBSTRING
				; COPYING 3 CHARACTERS STARTING AT INDEX 4
				; FROM '12.345E+10' GIVES '345'
	BRA	SC5D		; LOOP THROUGH TEST
;
; DATA SECTION
;

END
	IDX	FCB	4	; STARTING INDEX FOR COPYING
	CNT	FCB	3	; NUMBER OF CHARACTERS TO COPY
	MXLEN	FCB	32	; MAXIMUM LENGTH OF DESTINATION STRING
	SSTG	FCB	10	; LENGTH OF STRING
		FCC	/12.345E+10                      / 32 BYTE MAX
	DSTG	FCB	0	; LENGTH OF SUBSTRING
		FCC	/                                / 32 BYTE MAX


