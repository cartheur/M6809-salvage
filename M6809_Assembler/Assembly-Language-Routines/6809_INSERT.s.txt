	.macro	CLC
		ANDCC	#$FE
	.endm
	.macro	SEC
		ORCC	#1
	.endm

;	Title:			Insert a Substring into a String
;
;	Name:			INSERT 
;
;	Purpose:		Insert a substring into a string given a
;				starting index.
;
;	Entry:			TOP OF STACK
;
;				High byte of return address
;				Low  byte of return address
;				Maximum length of (source) string
;				Starting index to insert the substring 
;				High byte of substring address
;				Low  byte of substring address
;				High byte of (source) string address
;				Low  byte of (source) string address
;
;				Each string consists of a length byte
;				followed by a maximum of 255 characters.
;
;	Exit:			Substring inserted into string.
;				If no errors then
;				  Carry = 0
;				else
;				  begin
;				    the following conditions
;				     cause the Carry flag to be set.
;
;				    if index = 0 then
;				      do not insert the substring
;				    if Length(string) > maximum length then
;				      do not insert the substring
;				    if index > length(string) then
;				      concatenate substring onto 
;				      the end of the source string
;				    if Length(string)+Length(substring) > maxlen then
;				      insert only enough of the substring
;				      to reach maximum length
;				end
;
;	Registers Used:		All
;
;	Time:			Approximately 17 * (LENGTH(STRING) INDEX + 1)
;						+ 17 * (LENGTH(SUBSTRING)) 
;						+ 180 cycles overhead
;
;	Size:			Program 115 bytes
;
INSERT:
;	START WITH ERROR INDICATOR CLEARED
;	POINTERS INITIALIZED TO BASE ADDRESSES OF STRING, SUBSTRING
;	
	LDU	,S		; SAVE RETURN ADDRESS
	CLR	,S		; CLEAR ERROR INDICATOR (NO ERRORS)
	LDX	6,S		; GET BASE ADDRESS OF STRING
	LDY	4,S		; GET BASE ADDRESS 0F SUBSTRING
	;
	; EXIT IF SUBSTRING LENGTH IS ZERO OR STARTING INDEX IS ZERO
	;
	LDA	3,S		; GET STARTING INDEX
	BEQ	EREXIT		; EXIT, INDICATING ERROR,
				; IF STARTING INDEX IS ZERO (LENGTH BYTE)
	LDB	,Y		; GET LENGTH OF SUBSTRING (NUMBER OF
				; CHARACTERS TO INSERT
	BEQ	OKEXIT		; EXIT IF NOTHING TO INSERT (NO ERROR)
	;
	; CHECK WHETHER THE STRING WITH THE INSERTION FITS IN THE
	; SOURCE STRING (I.E., IF ITS LENGTH IS LESS THAN OR EQUAL
	; TO THE MAXIMUM).
	; IF NOT, TRUNCATE THE SUBSTRING AND SET THE ERROR FLAG
	;
	LDA	,Y		; GET SUBSTRING LENGTH
	ADDA	,X		; SUBSTRING LENGTH + STRING LENGTH
	BCS	TRUNC		; TRUNCATE SUBSTRING IF NEW LENGTH > 255
	CMPA	2,S		; COMPARE TO MAXIMUM STRING LENGTH
	BLS	IDXLEN		; BRANCH IF NEW LENGTH <= MAX LENGTH
	;
	; SUBSTRING DOES NOT FIT, SO TRUNCATE IT
	;
TRUNC:
	LDB	2,S		; NUMBER OF CHARACTERS TO INSERT =
	SUBB	[6,S]		; MAXIMUM LENGTH STRING LENGTH
	BLS	EREXIT		; TAKE ERROR EXIT 
				; IF MAXIMUM LENGTH <= STRING LENGTH
	COM	,S		; INDICATE SUBSTRING WAS TRUNCATED
	;
	; CHECK WHETHER STARTING INDEX IS WITHIN THE STRING.
	; IF NOT, CONCATENATE SUBSTRING ONTO THE END OF THE STRING
	;
IDXLEN:
	STB	1,S		; SAVE NUMBER OF CHARACTERS TO INSERT
	LDA	,X		; GET STRING LENGTH
	CMPA	3,S		; COMPARE TO STARTING INDEX
	BCC	LENOK		; BRANCH IF STARTING INDEX IS WITHIN STRING
	INCA			; ELSE SET STARTING INDEX TO END OF STRING
	STA	3,S
	LDA	#$FF		; INDICATE ERROR IN INSERT
	STA	,S
	BRA	MVESUB		; JUST PERFORM MOVE, NOTHING TO OPEN UP
	;
	; OPEN UP A SPACE IN SOURCE STRING FOR THE SUBSTRING BY MOVING
	; THE CHARACTERS FROM THE END OF THE SOURCE STRING DOWN TO
	; INDEX, UP BY THE SIZE OF THE SUBSTRING
	;
LENOK:
	;
	; CALCULATE NUMBER OF CHARACTERS TO MOVE
	; COUNT STRING := LENGTH - STARTING INDEX + 1
	;
	LDB	,X		; GET STRING LENGTH
	SUBB	2,S		; SUBTRACT STARTING INDEX
	INCB			; ADD 1
	;
	; SET SOURCE AND DESTINATION POINTERS
	;
	LEAX	A,X		; POINT TO END OF STRING
	LEAX	1,X		; POINT JUST PAST END OF STRING
	LDA	1,S		; ADD NUMBER OF CHARACTERS TO INSERT
	LEAY	A,X		; POINT JUST PAST END 0F DESTINATION AREA
	;
	; MOVE CHARACTERS UP IN MEMORY TO MAKE ROOM FOR SUBSTRING
	;
OPNLP:
	LDA ,-X     ; GET NEXT CHARACTER
	STA	,-Y		; MOVE IT UP IN MEMORY
	DECB			; DECREMENT COUNTER
	BNE	OPNLP		; CONTINUE THROUGH NUMBER OF CHARACTERS
	;
	; MOVE SUBSTRING INTO THE OPEN AREA
	;
MVESUB:
	LDX	6,S		; GET STRING ADDRESS
	LDA	3,S		; GET STARTING INDEX
	LEAX	A,X		; POINT TO START OF OPEN AREA
	LDY	4,S		; GET SUBSTRING ADDRESS
	LDB	1,S		; GET NUMBER OF CHARACTERS TO INSERT
	LEAY	1,Y		; POINT TO START OF SUBSTRING
	;
	; MOVE SUBSTRING BYTE AT A TIME
	;
MVELP:
	LDA	,Y+	`	; GET CHARACTER FROM SUBSTRING
	STA	,X+		; MOVE IT INTO OPEN AREA
	DECB			; DECREMENT COUNTER
	BNE	MVELP		; CONTINUE UNTIL COUNTER = 0
	;
	; CALCULATE NEW STRING LENGTH
	; NEW LENGTH = OLD LENGTH PLUS NUMBER OF CHARACTERS
	; TO INSERT 
	;
	LDX	6,S		; POINT TO STRING LENGTH
	LDA	,X		; GET STRING LENGTH
	ADDA	1,S		; ADD NUMBER 0F CHARACTERS TO INSERT
	STA	,X		; SAVE SUM AS NEW STRING LENGTH
	;
	; CHECK ERROR FLAG
	;
	LDA	,S		; CHECK ERROR FLAG
	BNE	EREXIT		; BRANCH IF ERROR OCCURRED
	;
	; SET CARRY FROM ERROR FLAG OR TEST
	; CARRY = 0 IF NO ERRORS, 1 IF ERRORS
	;
OKEXIT:
	CLC			; NO ERRORS
	BRA	EXITIN
EREXIT:
	SEC			; ERROR EXIT
	;
	; REMOVE PARAMETERS FROM STACK AND EXIT
	;
EXITIN:
;
	LEAS	8,S		; REMOVE PARAMETERS FROM STACK
	JMP	,U		; EXIT TO RETURN ADDRESS
;
; SAMPLE EXECUTION:
;
SC5F:
	LDY	#STG		; BASE ADDRESS OF STRING
	LDX	#SSTG		; BASE ADDRESS OF SUBSTRING
	LDB	IDX		; STARTING INDEX
	LDA	MXLEN		; MAXIMUM LENGTH OF STRING
	PSHS	D,X,Y		; SAVE PARAMETERS IN STACK
	JSR	INSERT		; INSERT SUBSTRING
				; RESULT OF INSERTING INTO '123456' AT
				; INDEX 1 IS '-123456'
	JMP	SC5F		; LOOP THROUGH TEST
;
; DATA SECTION
;
IDX:	FCB	1		; STARTING INDEX FOR INSERTION

MXLEN:	FCB	32		; MAXIMUM LENGTH OF DESTINATION
STG:	FCB	6		; LENGTH OF STRING
	FCC	/                                 / 32 BYTE MAX
SSTG:	FCB	1		; LENGTH OF SUBSTRING
	FCC	/                                 / 32 BYTE MAX

	END
