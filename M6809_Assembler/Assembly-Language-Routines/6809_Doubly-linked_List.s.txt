	.macro	CLC
		ANDCC	#$FE
	.endm
	.macro	SEC
		ORCC	#1
	.endm

;	Title:		Doubly linked List Manager 
;
;	Name:		INDLST, RMDLST 
;
;	Purpose:	This program consists of two subroutines
;			that manage a doubly linked list.
;
;			INDLST inserts an element into the doubly linked List.
;
;			RMDLST removes an element from the doubly linked list.
;
;	Entry:			INDLST
;				TOP OF STACK 
;				High byte of return address
;				Low  byte of return address 
;				High byte of previous element's address 
;				Low  byte of previous eLement's address 
;				High byte of entry address 
;				Low  byte of entry address
;			RMDLST	Base address of preceding element in register X
;
;	Exit:			INDLST
;					Element inserted into list
;				RMDLST
;					If following element exists,
;						its base address is in register X
;						Carry = 0
;					else
;						register X = 0
;						Carry = 1
;
;	Registers Used:		INDLST	All
;
;				RMDLST	CC,U,X,Y
;
;	Time:			INDLST	53 cycles
;
;				RMDLST	44 cycles
;
;	Size:			Program 35 bytes

;
;	INSERT AN ELEMENT INTO A DOUBLY LINKED LIST
;
INDLST:
	; UPDATE LINKS TO INCLUDE NEW ELEMENT
	; LINK PREVIOUS ELEMENT TO NEW ELEMENT
	; LINK NEW ELEMENT TO PREVIOUS AND FOLLOWING ELEMENTS
	; LINK FOLLOWING ELEMENT TO NEW ELEMENT
	;
	PULS	D,X,Y		; GET RETURN ADDRESS, ELEMENTS
	LDU	2,X		; GET FOLLOWING ELEMENT
	STY	2,X		; MAKE NEW ELEMENT INTO PREVIOUS
				; ELEMENT'S FORWARD LINK
	STX	,Y		; MAKE PREVIOUS ELEMENT INTO NEW
				; ELEMENT'S BACKWARD LINK
	STU	2,Y		; MAKE FOLLOWING ELEMENT INTO NEW
				; ELEMENT'S FORWARD LINK
	STY	,U		; MAKE NEW ELEMENT INTO FOLLOWING
				; ELEMENT'S BACKWARD LINK
	; NOTE:	IF LINKS ARE NOT IN FIRST FOUR BYTES OF ELEMENTS,
	;	PUT LINK OFFSETS IN LAST 5 INSTRUCTIONS
	;
	;
	; EXIT
	;
	PSHS	D		; PUT RETURN ADDRESS BACK IN STACK
	RTS			; EXIT
;
;	REMOVE AN ELEMENT FROM A DOUBLY LINKED LIST
RMDLST:
	;
	; EXIT INDICATING FAILURE (CARRY SET) IF NO FOLLOWING ELEMENT
	;
	LDY	2,X		; GET LINK TO FOLLOWING ELEMENT
	SEC			; INDICATE NO ELEMENT FOUND
	BEQ	RMDXIT		; BRANCH IF NO ELEMENT FOUND
	;
	; ELEMENT EXISTS SO UNLINK IT BY TRANSFERRING ITS
	; FORWARD LINK TO PREVIOUS ELEMENT AND ITS BACKWARD
	; LINK TO FOLLOWING ELEMENT
	; NOTE:	IF LINKS ARE NOT IN THE FIRST FOUR BYTES OF THE
	; ELEMENTS, PUT CORRECT LINK OFFSETS IN STATEMENTS
	;
	LDU	2,Y		; GET FOLLOWING ELEMENT
	STU	2,X		; MAKE FOLLOWING ELEMENT INTO FORWARD
				; LINK OF PRECEDING ELEMENT
	STX	,U		; MAKE PRECEDING ELEMENT INTO BACKWARD
				; LINK OF FOLLOWING ELEMENT
	CLC			; INDICATE ELEMENT FOUND
	;
	; EXIT
RMDXIT:
	TFR	Y,X		; EXIT WITH BASE ADDRESS OF REMOVED
				; ELEMENT OR 0 IN X
	RTS			; CARRY = 0 IF ELEMENT FOUND, 1 IF NOT
;
; SAMPLE EXECUTION
;
SC7D:
	;
	; INITIALIZE EMPTY DOUBLY LINKED LIST
	;
	LDD	#0		; CLEAR LINKED LIST HEADER
	STD	HDRFWD		; FORWARD LINK
	STD	HDRBCK		; BACKWARD LINK
				; 0 INDICATES NO LINK IN THAT
				; DIRECTION
	;
	; INSERT ELEMENT INTO DOUBLY LINKED LIST
	;
	LDY	#ELEM1		; GET BASE ADDRESS OF ELEMENT 1
	LDX	#HDRFWD		; GET PREVIOUS ELEMENT (HEADER)
	PSHS	X,Y		; SAVE PARAMETERS IN STACK
	JSR	INDLST		; INSERT ELEMENT INTO LIST
	;
	; INSERT ANOTHER ELEMENT INTO DOUBLY LINKED LIST
	;
	LDY	#ELEM2		; GET BASE ADDRESS OF ELEMENT 2
	LDX	#ELEM1		; GET PREVIOUS ELEMENT
	PSHS	X,Y		; SAVE PARAMETERS IN STACK
	JSR	INDLST		; INSERT ELEMENT INTO LIST
	;
	; REMOVE FIRST ELEMENT FROM DOUBLY LINKED LIST
	;
	LDX	#HDRFWD		; GET PREVIOUS ELEMENT
	JSR	RMDLST		; REMOVE ELEMENT FROM LIST
				;
				; END UP WITH HEADER LINKED TO
				; SECOND ELEMENT
				; X CONTAINS BASE ADDRESS
				; OF FIRST ELEMENT
				;
	BRA	SC7D		; REPEAT TEST
;
; DATA
;
HDRFWD	RMB	2		; HEADER FORWARD LINK
HDRBCK	RMB	2		; HEADER BACKWARD LINK
ELEM1	RMB	2		; ELEMENT 1 HEADER (LINKS) ONLY
ELEM2	RMB	2		; ELEMENT 2 HEADER (LINKS) ONLY

	END

