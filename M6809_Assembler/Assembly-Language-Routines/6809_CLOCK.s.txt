	.macro	CLI
		ANDCC	#$EF
	.endm

;	Title:		Real time clock and calendar CLOCK	
;	Name:		CLOCK
;
;	Purpose:	This program maintains a time of day 24 hour clock and
;			a calendar based on a real time clock
;			interrupt from a 6840 programmable timer.
;
;			CLOCK
;				Returns base address of clock variables
;			ICLK
;				Initializes 6840 timer and clock interrupt
;
;	Entry:
;			CLOCK
;				None
;			ICLK
;				None
;	Exit:
;			CLOCK
;				Register X = Base address of time variables
;			ICLK
;				None
;
;	Registers Used:
;			A,B,CC,X,Y
;
;	Time:
;			CLOCK
;				8 cycles
;			ICLCK
;				115 cycles
;			CLKINT
;				If decrementing tick only, 59 cycles
;				Maximum if changing to a new year, 244 cycles
;				These include the 21 cycles required for 
;				the processor to respond to an interrupt.
;
;	Size:
;
;	
;	Program		190 bytes
;	Data		 8 bytes
;
; 6840 PROGRAMMABLE TIMER MODULE (PTM)
;
; INITIALIZE TIMER 2 OF 6840 PTM AS 50 HZ SQUARE HAVE GENERATOR
; FOR USE IN TIME-OF-DAY CLOCK.
;
; TIMER GENERATES INTERRUPT AT END OF EACH 10 MS INTERVAL (EVERY HALFCYCLE)
;
; WE ASSUME A 1 MHZ CLOCK INTO THE 6840, SO THAT A COUNTER VALUE
; OF 1,000,000/100-1 = 9,999 (270F HEX)
; IS NEEDED TO GENERATE A 50 HZ SQUARE WAVE
;
; ARBITRARY MEMORY ADDRESSES FOR 6840 PTM
;
	PTMC13	EQU	$A800	; CONTROL REGISTERS 1 AND 3
	PTMCR2	EQU	$A801	; CONTROL REGISTER 2
	PTMT1H	EQU	$A802	; TIMER	1, MORE SIGNIFICANT BYTE
	PTMT1L	EQU	$A803	; TIMER	1, LESS SIGNIFICANT BYTE
	PTMT2H	EQU	$A804	; TIMER	2, MORE SIGNIFICANT BYTE
	PTMT2L	EQU	$A805	; TIMER	2, LESS SIGNIFICANT BYTE
	PTMT3H	EQU	$A806	; TIMER	3, MORE SIGNIFICANT BYTE
	PTMT3L	EQU	$A807	; TIMER	3, LESS SIGNIFICANT BYTE
	PTMSR	EQU	$A801	; STATUS REGISTER
	PTMT2C	EQU	$A804	; TIMER 2 COUNTER
;
; 6840 PTM MODE BYTE, COUNTER VALUE
;
	PTMMOD	EQU	01000000b
				; BIT 0 = 0 TO ACCESS CR3
				; BIT 1 = 0 TO USE ENABLE CLOCK
				; BIT 2 = 0 FOR COUNT MODE
				; BITS	3,S = 00 FOR CONTINUOUS COUNTING
				; BIT 4 = 0 FOR ACTIVATE WHEN LATCHES WRITTEN
				; BIT 6 = 1 TO ENABLE INTERRUPT
				; BIT 7 = 0 TO DISABLE OUTPUT

PTMCNT	EQU	9999		; COUNTER VALUE = 9999
;
; DEFAULT TICK VALUE (100 HZ REALTIME CLOCK)
;
DTICK	EQU	100		; DEFAULT TICK VALUE
;
; RETURN BASE ADDRESS OF CLOCK VARIABLES
;
CLOCK:
	LDX	#CLKVAR		; GET BASE ADDRESS OF CLOCK VARIABLES
	RTS
;
; INITIALIZE 6840 PTM TO PRODUCE REGULAR CLOCK INTERRUPTS
; OPERATE TIMER 2 CONTINUOUSLY, PRODUCING AN INTERRUPT EVERY
; 100 MS
;
ICLK:	LDA	#00000001b
	STA	PTMCR2		; ADDRESS CONTROL REGISTER 1
	STA	PTMC13		; RESET TIMERS
	CLR	PTMC13		; ALLOW TIMERS TO OPERATE
	LDD	#0		; CLEAR COUNTERS 1,3
	LDA	#PTMMOD		; SET TIMER 2'S OPERATING MODE
	STA	PTMCR2
	LDD	#PTMCNT		; PUT COUNT IN TIMER 2
	STD	PTMT2H		; START TIMER 2
;
; INITIALIZE CLOCK VARIABLES TO ARBITRARY VALUE
; JANUARY 1, 1980 00:00.00 (12 A.M.)
; A REAL CLOCK WOULD NEED OUTSIDE INTERVENTION
; TO SET OR CHANGE VALUES
;
	LDX	#TICK
	LDA	#DTICK
	STA	,X		; INITIALIZE TICKS
	CLRA
	STA	1,X		; SECOND = 0 
	STA	2,X		; MINUTE = 0 
	STA	3,X		; HOUR = 0
	LDA	#1		; A = 1
	STA	4,X		; DAY = 1 (FIRST)
	STA	5,X		; MONTH = 1 (JANUARY)
	LDY	#1980
	STY	6,X		; YEAR = 1980
	CLI			; ENABLE INTERRUPTS
	RTS
;
; SERVICE CLOCK INTERRUPT
;
CLKINT:
	LDA	PTMSR		; CLEAR INTERRUPT BY READING STATUS
	LDA	PTMT2C		; AND THEN COUNTER
	LDX	#CLKVAR
	DEC	TICKIDX,X	; SUBTRACT 1 FROM TICK COUNT
	BNE	EXITCLK		; JUMP IF TICK COUNT NOT ZERO
	LDA	#DTICK		; SET TICK COUNT BACK TO DEFAULT
	STA	TICKIDX,X	;
;
; SAVE REMAINING REGISTERS
	CLRA			; 
;
; INCREMENT SECONDS
;
	INC	SECIDX,X	; INCREMENT TO NEXT SECOND
	LDA	SECIDX,X
	CMPA	#60		; SECONDS = 60?
	BCS	EXITCLK		; EXIT IF LESS THAN 60 SECONDS
	CLR	SECIDX,X	; ELSE SECONDS = 0
;
; INCREMENT MINUTES
;
	INC	MINIDX,X	; INCREMENT TO NEXT MINUTE
	LDA	MINIDX,X
	CMPA	#60		; MINUTES = 60?
	BCS	EXITCLK		; EXIT IF LESS THAN 60 MINUTES
	CLR	MINIDX,X	; ELSE MINUTES = 0
;
; INCREMENT HOURS
;
	INC	HRIDX,X		; INCREMENT TO NEXT HOUR
	LDA	HRIDX,X
	CMPA	#24		; HOURS = 24?
	BCS	EXITCLK		; EXIT IF LESS THAN 24 HOURS
	CLR	HRIDX,X		; ELSE HOURS = 0
;
; INCREMENT DAY
;
	LDA	MTHIDX,X	; GET CURRENT MONTH
	LDY	#LASTDY
	LDA	A,Y		; GET LAST DAY OF CURRENT MONTH
	INC	DAYIDX,X	; INCREMENT DAY
	CMPA	DAYIDX,X	; IS IT LAST DAY?
	BCS	EXITCLK		; EXIT IF NOT AT END OF MONTH
;
; DETERMINE IF THIS IS END OF FEBRUARY IN A LEAP
; YEAR (YEAR DIVISIBLE BY 4)
;
	LDA	MTHIDX,X	; GET MONTH
	CMPA	#2		; IS THIS FEBRUARY?
	BNE	INCMTH		; JUMP IF NOT, INCREMENT MONTH
	LDA	YRIDX+1,X	; IS IT A LEAP YEAR?
	ANDA	#00000011b
	BNE	INCMTH		; JUMP IF NOT
;
; FEBRUARY OF A LEAP YEAR HAS 29 DAYS, NOT 28 DAYS
;
	LDA	DAYIDX,X	; GET DAY
	CMPA	#29
	BCS	EXITCLK		; EXIT IF NOT 1ST OF MARCH
;
; INCREMENT MONTH
;
INCMTH:
	LDA	#1		; DEFAULT IS 1 FOR DAY AND MONTH
	STA	DAYIDX,X	; DAY = 1
	LDA	MTHIDX,X
	INC	MTHIDX,X	; INCREMENT MONTH 
	CMPA	#12		; HAS OLD MONTH DECEMBER? 
	BCS	EXITCLK		; EXIT IF NOT 
	LDA	#1		; ELSE
				; CHANGE MONTH TO 1 (JANUARY) 
	STA	MTHIDX,X

; INCREMENT YEAR

	LDD	YRIDX,X		; GET YEAR
	ADDD	#1		; ADD 1 TO YEAR
	STD	YEAR		; STORE NEW YEAR


EXITCLK:			; RESTORE REGISTERS AND EXIT
	RTI			; RETURN

; ARRAY OF LAST DAYS OF EACH MONTH

LASTDY:
	FCB	31		; JANUARY
	FCB	28		; FEBRUARY (EXCEPT LEAP YEARS)
	FCB	31		; MARCH
	FCB	30		; APRIL
	FCB	31		; MAY
	FCB	30		; JUNE
	FCB	31		; JULY
	FCB	31		; AUGUST
	FCB	30		; SEPTEMBER
	FCB	31		; OCTOBER
	FCB	30		; NOVEMBER
	FCB	31		; DECEMBER
;
; CLOCK VARIABLES
;
CLKVAR:
TICK:	RMB	1		; TICKS LEFT IN CURRENT SECOND
SEC:	RMB	1		; SECONDS
MIN:	RMB	1		; MINUTES
HOUR:	RMB	1		; HOURS
DAY:	RMB	1		; DAY (1 TO NUMBER OF DAYS IN A MONTH)
MONTH:	RMB	1		; MONTH 1=JANUARY .. 12=DECEMBER
YEAR:	RMB	2		; YEAR
;
; SAMPLE EXECUTION
;
; CLOCK VARIABLE INDEXES
;
TCKIDX	EQU	0		; INDEX TO TICK
SECIDX	EQU	1		; INDEX TO SECOND
MINIDX	EQU	2		; INDEX TO MINUTE
HRIDX	EQU	3		; INDEX TO HOUR
DAYIDX	EQU	4		; INDEX TO DAY
MTHIDX	EQU	5		; INDEX TO MONTH
YRIDX	EQU	6		; INDEX TO YEAR
;
SC9D:
	JSR	ICLK		; INITIALIZE CLOCK
;
; INITIALIZE CLOCK TO 2/7/86 14:00:00 (2 PM, FEB.	7, 1986)
;
	JSR	CLOCK		; X = ADDRESS OF CLOCK VARIABLES
	CLR	SEC		; SECONDS = 0
	CLR	MIN		; MINUTES = 0
	LDA	#14		; HOUR = 14 (2 PM)
	STA	HOUR
	LDA	#7		; DAY = 7
	STA	DAY
	LDA	#2		; MONTH = 2 (FEBRUARY)
	STA	MONTH
	LDX	#1986
	STX	YEAR
;
; WAIT FOR CLOCK TO BE 2/7/86 14:01:20 (2:01.20 PM, FEB. 7, 1986)
;
; NOTE:	MUST BE CAREFUL TO EXIT IF CLOCK IS ACCIDENTALLY SET AHEAD.
;	IF WE CHECK ONLY FOR EQUALITY, WE MIGHT NEVER FIND IT.
;	THUS WE HAVE IN TESTS BELOW, NOT JUST =.
;
;	WAIT FOR YEAR >= TARGET YEAR
;
	JSR	CLOCK		; X = BASE ADDRESS OF CLOCK VARIABLES
	LDY	TYEAR		; Y = YEAR TO WAIT FOR

WAITYR:
				; COMPARE CURRENT YEAR AND TARGET YEAR
	CMPY	YEAR
	BMI	WAITYR		; BRANCH IF YEAR NOT >= TARGET YEAR
;
; WAIT FOR REST OF TIME UNITS TO BE GREATER THAN OR EQUAL
; TO TARGET VALUES
;
	LDY	#TARGET		; POINT TO TARGET VALUES
	LEAX	MTHIDX,X	; POINT TO END OF TIME VALUES
	LDB	NTUNIT		; NUMBER OF TIME UNITS IN COMPARISON
;
; GET NEXT TARGET VALUE
;
WTTIM:
	LDA	,Y+		; GET NEXT TARGET VALUE
;
; WAIT FOR TIME TO BE GREATER THAN OR EQUAL TO TARGET
;
WTUNIT:
	CMPA	,X
	BMI	WTUNIT		; BRANCH IF UNIT NOT >= TARGET VALUE
	LEAX	=1,X		; PROCEED TO NEXT UNIT
	DECB			; DECREMENT NUMBER OF TIME UNITS
	BNE	WTTIM		; CONTINUE UNTIL ALL UNITS CHECKED
;
; DONE
;
HERE:
	BRA	HERE		; IT IS NOW TIME OR LATER
;
; TARGET TIME - 2/7/87, 14:01:20 (2:01.20 PM, FEB. 7, 1987)
;
TYEAR:	FDB	1987		; TARGET YEAR
NTUNIT:	FCB	5		; NUMBER OF TIME UNITS IN COMPARISON
TARGET:	FCB	2,7,14,1,20	; TARGET TIME (MONTH,DAY,HR,MIN,SEC)
	END

