;	Name:		Block Move
;
;	Title:		BLKMOV
;
;	Purpose:
;
;	Move data from source to destination
;
;	Entry:		TOP OF STACK
;				High byte of return address
;				Low  byte of return address
;				High byte of number of bytes to move
;				Low  byte of number of bytes to move
;				High byte of base address of destination area
;				Low  byte of base address of destination area
;				High byte of base address of source area
;				Low  byte of base address of source area
;
;	Exit:			Data moved from source to destination
;
;	Registers Used:		All
;
;	Time:			20 cycles per byte
;				Overhead is: 59 cycles if no problem with
;				overlap, 95 cycles if overlap
;
;	Size:			Program 55 bytes
;
BLKMOV:
;
;	EXIT IMMEDIATELY IF AREA SIZE IS 0
;
	LDD	2,S			; GET AREA SIZE
	BEQ	BLKEXIT			; RETURN IMMEDIATELY IF SIZE IS ZERO
;
;	DETERMINE IF DESTINATION AREA IS ABOVE SOURCE AREA AND
;	OVERLAPS IT (OVERLAP CAN BE MOD 64K).
;	OVERLAP OCCURS IF BASE ADDRESS OF DESTINATION AREA
;	MINUS BASE ADDRESS OF SOURCE AREA (MOD 64K)
;	IS LESS THAN NUMBER OF BYTES TO MOVE
;
	LDD	4,S			; GET BASE ADDRESS OF DESTINATION
	SUBD	6,S			; SUBTRACT BASE ADDRESS OF SOURCE
	CMPD	2,S			; COMPARE DIFFERENCE TO AREA SIZE	
	BLO	MVRIGHT			; BRANCH IF OVERLAP PROBLEM
;
;	NO OVERLAP SO MOVE BLOCK STARTING FROM LOWEST ADDRESS
;
MVLEFT:
	PULS	D,X,Y			; GET RETURN ADDRESS, SIZE, DESTINATION 
	LDU	,S			; GET SOURCE ADDRESS
	STD	,S			; PUT RETURN ADDRESS BACK IN STACK
BYTEL:	LDA	,U+			; GET NEXT BYTE FROM SOURCE
	STA	,Y+			; MOVE IT TO DESTINATION
	LEAX	-1,X			; DECREMENT BYTE COUNTER
	BNE	BYTEL			; CONTINUE UNTIL COUNTER = 0
	RTS
;
;	OVERLAP SO MOVE BLOCK STARTING FROM HIGHEST ADDRESS
;	TO AVOID DESTROYING DATA
;
MVRIGHT:
	LDD	4,S			; GET BASE ADDRESS OF DESTINATION 
	ADDD	2,S			; ADD LENGTH TO OBTAIN TOP ADDRESS
	TFR	D,Y			; SAVE TOP ADDRESS OF DESTINATION 
	LDD	6,S			; GET BASE ADDRESS OF SOURCE
	ADDD	2,S			; ADD LENGTH TO OBTAIN TOP ADDRESS 
	TFR	D,U			; SAVE TOP ADDRESS OF SOURCE
	PULS	D,X			; GET RETURN ADDRESS, SIZE
	LEAS	2,S			; ADJUST STACK POINTER TO REMOVE EXTRA BYTES 
	STD	,S			; PUT RETURN ADDRESS BACK IN STACK 

BYTER:
	LDA	,-U			; GET NEXT BYTE FROM SOURCE
	STA	,-Y			; MOVE IT TO DESTINATION
	LEAX	-1,X			; DECREMENT BYTE COUNTER
	BNE	BYTEL			; CONTINUE UNTIL COUNTER = 0
BLKEXIT:
	RTS
;
;	SAMPLE EXECUTION
;
SRC1:	EQU	$1000			; BASE ADDRESS OF FIRST SOURCE AREA 
SRC2:	EQU	$2008			; BASE ADDRESS OF SECOND SOURCE AREA 
DEST:	EQU	$2010			; BASE ADDRESS OF DESTINATION AREA 
LEN:	EQU	$11			; NUMBER OF BYTES TO MOVE
;
SC2B:
;	MOVE 11 HEX BYTES FROM 1000-1010 HEX TO 2010-2020 HEX 
;	DEMONSTRATES MOVE LEFT (LOWEST ADDRESS UP)
;
	LDU	#SRC1			; BASE ADDRESS OF SOURCE AREA
	LDY	#DEST			; BASE ADDRESS OF DESTINATION AREA 
	LDX	#LEN			; NUMBER OF BYTES TO MOVE
	PSHS	U,X,Y			; SAVE PARAMETERS IN STACK
	JSR	BLKMOV			; MOVE DATA FROM SOURCE TO DESTINATION
;
;	MOVE 11 HEX BYTES FROM 2008-2018 HEX TO 2010-2020 HEX 
;	DEMONSTRATES MOVE RIGHT (HIGHEST ADDRESS DOWN) 
;	SINCE SOURCE AND DESTINATION AREAS OVERLAP AND DESTINATION IS
;	ABOVE SOURCE
;
	LDU	#SRC2			; BASE ADDRESS OF SOURCE AREA
	LDY	#DEST			; BASE ADDRESS OF DESTINATION AREA LDX #LEN NUMBER OF
	LDX	#LEN			; BYTES TO MOVE
	PSHS	U,X,Y			; SAVE PARAMETERS IN STACK
	JSR	BLKMOV			; MOVE DATA FROM SOURCE TO DESTINATION
	END


