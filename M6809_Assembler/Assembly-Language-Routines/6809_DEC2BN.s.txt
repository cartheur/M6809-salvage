;	Title:			Decimal ASCII to Binary
;	Name:			DEC2BN
;
;	Purpose:		Converts ASCII characters to two bytes of binary data
;
;	Entry:			Register X = Input buffer address 
;
;	Exit:			Register D = Binary data 
;				If no errors then
;					Carry = 0
;				else
;					Carry = 1
;	
;	Registers Used:		All
;
;	Time:			Approximately 60 cycles per ASCII digit
;				plus a maximum of 125 cycles overhead
;
;	Size:			Program 154 bytes
;				Data	  2 bytes on stack
DEC2BN:
;
;	SAVE BUFFER POINTER, INITIALIZE BINARY VALUE TO ZERO
;
	TFR	X,Y			; SAVE BUFFER POINTER TO EXAMINE SIGN LATER
	LDD	#0			; INITIALIZE BINARY VALUE TO ZERO
	PSHS	D			; SAVE BINARY VALUE ON STACK
	LDA	,X+			; GET BYTE COUNT
;
;	CHECK IF FIRST BYTE OF ACTUAL STRING IS SIGN
;
	LDB	,X+			; GET FIRST BYTE OF ACTUAL STRING
	CMPB	#'-'			; CHECK IF IT IS ASCII -
	BEQ	STMSD			; BRANCH IF IT IS
	CMPB	#'+'			; CHECK IF IT IS ASCII +
	BEQ	STMSD			; BRANCH IF IT IS			
;
;	FIRST BYTE IS NOT A SIGN
;	SET A FLAG, MOVE POINTER BACK TO START AT FIRST DIGIT
;	INCREASE BYTE COUNT BY 1 SINCE NO SIGN INCLUDED
;
	CLR	-2,X			; INDICATE NO SIGN IN BUFFER
	LEAX	-1,X			; MOVE POINTER BACK TO FIRST DIGIT
	INCA				; ADD 1 TO BYTE COUNT
;
;	START CONVERSION AT MOST SIGNIFICANT DIGIT IN BUFFER
;	COULD BE UP TO SIX BYTES INCLUDING SIGN
;
STMSD:
	CMPA	#6			; LOOK FOR 1000O'S DIGIT
	BEQ	TENKD			; BRANCH IF FOUND
	CMPA	#5			; LOOK FOR 1000'S DIGIT
	BEQ	ONEKD			; BRANCH IF FOUND	
	CMPA	#4			; LOOK FOR 100'S DIGIT
	BEQ	HUNDD			; BRANCH IF FOUND
	CMPA	#3			; LOOK FOR TENS DIGIT
	BEQ	TENSD			; BRANCH IF FOUND
	CMPA	#2			; LOOK FOR ONES DIGIT
	BEQ	ONESD			; BRANCH IF FOUND
	CMPA	#2			; LOOK FOR ONES DIGIT
	BRA	ERREXIT			; NO DIGITS, INDICATE ERROR
;
;	CONVERT 10000'S DIGIT TO BINARY
;	10000 = 40*250 
;	NOTE: MUL CANNOT MULTIPLY BY MORE THAN 255
;
TENKD:
	LDB	,X+			; GET 10000'S ASCII DIGIT
	JSR	CHVALD			; CONVERT TO BINARY, CHECK VALIDITY
	CMPB	#3			; CHECK IF DIGIT TO0 LARGE
	BHI	ERREXIT			; TAKE ERROR EXIT IF IT IS
	LDA	#40			; MULTIPLY BY 10000 IN TWO STEPS
	MUL				; FIRST MULTIPLY BY 40
	LDA	#250			; THEN MULTIPLY BY 250
	MUL
	ADDD	,S			; ADD PRODUCT TO BINARY VALUE
	STD	,S			; SAVE SUM ON STACK
;
;	CONVERT 1000'S DIGIT TO BINARY
;	1000 = 40 * 250
;	NOTE: MUL CANNOT MULTIPLY BY MORE THAN 255
;
ONEKD:
	LDB	,X+			; GET 1000'S ASCII DIGIT 
	JSR	CHVALD			; CONVERT TO BINARY, CHECK VALIDITY 
	LDA	#4			; MULTIPLY BY 1000 IN TWO STEPS
	MUL				; FIRST MULTIPLY BY 4
	LDA	#250			; THEN MULTIPLY BY 250
	MUL
	ADDD	,S			; ADD PRODUCT TO BINARY VALUE 
	STD	,S			; SAVE SUM ON STACK
;
;	CONVERT 100'S DIGIT TO BINARY
;
HUNDD:

	LDB	,X+			; GET 100'S ASCII DIGIT
	JSR	CHVALD			; CONVERT TO BINARY, CHECK VALIDITY 
	LDA	#100			; MULTIPLY BY 100
	MUL
	ADDD	,S			; ADD PRODUCT TO BINARY VALUE
	STD	,S			; SAVE SUM ON STACK
;
;	CONVERT TENS DIGIT TO BINARY
;
TENSD:
	LDB	,X+			; GET 10'S ASCII DIGIT
	JSR	CHVALD			; CONVERT TO BINARY, CHECK VALIDITY 
	LDA	#10			; MULTIPLY BY 10
	MUL
	ADDD	,S			; ADD PRODUCT TO BINARY VALUE
	STD	,S			; SAVE SUM ON STACK
;
;	CONVERT ONES DIGIT TO BINARY
;
ONESD:	LDB	,X+			; GET ONES ASCII DIGIT
	JSR	CHVALD			; CONVERT TO BINARY, CHECK VALIDITY
	CLRA				; EXTEND TO 16 BITS
	ADDD	,S			; ADD DIGIT TO BINARY VALUE
	STD	,S			; SAVE SUM ON STACK
;
;	CHECK FOR MINUS SIGN
;
	LDB	,Y			; CHECK IF THERE HAS A SIGN BYTE 
	BEQ	VALEXIT			; BRANCH IF NO SIGN
	LDB	1,Y			; GET SIGN BYTE
	CMPB	#'-'			; CHECK IF IT IS ASCII -
	BNE	VALEXIT			; BRANCH IF IT ISN'T
; 
;	NEGATIVE NUMBER, SO SUBTRACT VALUE FROM ZERO
;
	LDD	#0			; SUBTRACT VALUE FROM ZERO
	SUBD	,S
	STD	,S			; SAVE NEGATIVE AS VALUE
; 
; EXIT WITH BINARY VALUE IN D
;
VALEXIT:
	PULS	D			; RETURN TOTAL IN D
	CLC				; CLEAR CARRY, INDICATING NO ERRORS 
	RTS
;
;	ERROR EXIT - SET CARRY FLAG TO RETURN ERROR CONDITION
; 
ERREXIT: 
	PULS	D			; RETURN TOTAL IN D 
	SEC				; SET CARRY TO INDICATE ERROR RTS
	RTS
; **************************************************************
; ROUTINE:		CHVALD
; PURPOSE:		CONVERTS ASCII TO DECIMAL, CHECKS VALIDITY OF DIGITS
; ENTRY:		ASCII DIGIT IN B
; EXIT:			DECIMAL DIGIT IN B,
;			EXITS TO ERREXIT IF DIGIT INVALID
; REGISTERS USED:	B,CC
; **************************************************************
CHVALD:
	SUBB	#'0'			; CONVERT TO DECIMAL BY SUBTRACTING 
					; ASCII 0
	BCS	EREXIT			; BRANCH IF ERROR (VALUE T00 SMALL) 
	CMPB	#9			; CHECK IF RESULT IS DECIMAL DIGIT 
	BHI EREXIT			; BRANCH IF ERROR (VALUE T00 LARGE) 
	RTS				; RETURN DECIMAL DIGIT IN B
EREXIT:	LEAS	2,S			; REMOVE RETURN ADDRESS FROM STACK 
	BRA ERREXIT			; LEAVE VIA ERROR EXIT
;
; SAMPLE EXECUTION
;
SC1F:
	; CONVERT ASCII '1234' TO 04D2 HEX
	LDX	#S1			; BASE ADDRESS OF S1
	JSR	DEC2BN			; D = 04D2 HEX
	; CONVERT ASCII '+32767' TO 7FFF HEX
	LDX	#S2			; BASE ADDRESS OF S2
	JSR	DEC2BN			; D = 7FFF HEX
	; CONVERT ASCII '-32768' TO 8000 HEX
	LDX	#S3			; BASE ADDRESS OF S3
	JSR	DEC2BN			; D = 8000 HEX

S1:	FCB	4
	FCC	/1234/
S2:	FCB	6
	FCC	/+32767/
S3:	FCB	6
	FCC	/-32768/
	END

