dnl $ Id: $
dnl Copyright{2000,2001}: Albert van der Horst, HCC FIG Holland by GNU Public License
@section Getting started

@subsection Hello world!

Type forthsamp({thisforth}) to get into your interactive Forth system.
You will see a signon message.
While sitting in your interactive Forth doing a ``hello world'' is easy:
forthexample({"Hello world!" TYPE
Hello world! OK })
forthbreak
Making it into an interactively usable program is also easy:
forthexample(
{: HELLO "Hello world!" TYPE CR ;
OK
HELLO
Hello world!
OK })
This means you type the command forthsamp({HELLO}) while you
are in thisforth. As soon as you leave thisforth, this command
is gone.
_HOSTED_({
forthbreak
In order to make a stand alone program to say hello you have to
save the source to a file, such as forthfile({hello.frt}).
It just contains the definition we typed earlier:
forthexample({ : HELLO "Hello world!" TYPE CR ;})
Now build the program by
forthbreak
thisforth -c hello.frt
forthbreak
(That is forthkey({c}) for compile.)
The result is a file _HOSTED_LINUX_({forthfile({hello})}) _PC_({forthfile({HELLO.EXE})}).
For the compiler to run you must have the library correctly
installed.
})
If that failed, or anything else fails, you will
get a message with at least forthsamp({ ciforth ERROR ###})
and hopefully some more or less helpful text as well.
The forthsamp({###}) is an error number. forthxref({Errors}) Section Explanations.

Note for the old hands. Indeed the quoted strings are not ISO.
They surely are a Forth-like extension. Read up on denotations,
and the definition of forthcode({"}) .

In thisforth you never have to worry about those quoted strings,
they are allocated in the dictionary and are permanent.

@subsection The library.

If you want to run a program written on some other Forth, it
may use facilities that are not available in thisforth's kernel,
but they may be available in the forthdefi({library}).
A library is a store with facilities, available on demand.
Forth as such doesn't have a library mechanism,
but thisforth does.

thisforth uses the forthdefi({blocks}) as a library
by addition of the word forthcode({REQUIRED}) and a convention.
Starting with forthsamp({thisforth -r}) or most any option you have this
facility available. If you are already in thisforth, you can
type forthsamp({1 LOAD}).
_VERBOSE_({ The extension of forthsamp({.lab}) in
forthfile({forth.lab}) means Library Addressable by Block.})

Now we will add forthcode({DO-DEBUG}) using this library mechanism.
It is used immediately.
It is handy during development, after every line it
shows you what numbers Forth remembers for you.
Also from now on
the header of each
block that is forthcode({LOAD})-ed is shown. forthbreak
Type (forthsamp({1 LOAD}) may not be necessary):
forthexample({1 LOAD
"DO-DEBUG" REQUIRED
OK
DO-DEBUG

S[ ] OK 1

S[ 1 ] OK})
You can turn forthcode({DO-DEBUG}) off with forthcode({NO-DEBUG}) .

If you try to forthcode({INCLUDE}) a program, you may
get errors like forthsamp({TUCK? ciforth ERROR # 12 : NOT RECOGNIZED}).
forthxref({Errors}) Section Explanations.
Apparently, thisforth doesn't know about a forth word named
forthcode({TUCK}), but after forthsamp({"TUCK" REQUIRED}) maybe
it does. You may try again.

The convention about the way the library file must be
organized for forthcode({REQUIRED}) to find something is
simple. It is divided into blocks of 16 lines.
The first line is the header of the block. If the word
we are looking for is mentioned in the header, that
block is compiled.

The library file contains examples for you
to load using forthcode({REQUIRE}) .
Try
forthexample(
{REQUIRE SIEVE
LIM # 4 ISN'T UNIQUE
OK
10 SIEVE
KEY FOR NEXT SCREEN
ERATOSTHENES SIEVE -- PRIMES LESS THAN 10 000
0 002 003 ...
(lots of prime numbers.)})

@subsection Development.

If you want to try things out, or write a program -- as
opposed to just running a ready made program -- you best
_HOSTED_({start up thisforth by forthsamp({thisforth -e}).
That is forthkey({e}) for elective. That name means
that you}) _BOOTED_({do forthsamp({5 LOAD}) immediately. You})
 can configure this screen 5 to suit your particular needs.
dnl NEEDED description of adapting the elective screen
dnl We will come back to that later.
forthbreak
You will have available:
forthenumerate
forthitem
forthcode({REQUIRED}) and forthcode({REQUIRE}) .
forthsamp({REQUIRE xxx}) is equivalent to
forthsamp({"xxx" REQUIRED}) , but it is more convenient.
forthitem
 forthcode({DH.}) forthcode({H.}) forthcode({B.}) forthcode({DUMP}) forthcode({FARDUMP})
For showing numbers in hex and parts of memory.
 _PC_({
forthitem
 forthcode({EDIT})
The editor for editing blocks of the library file.
})_END_({_PC_})
forthitem
 forthcode({CRACK})
To analyse words, showing the source code of compiled words.
 _SOURCEFIELD_({
forthitem
 forthcode({LOCATE})
To show the block of the library file where a word is located.
 })_END_({_SOURCEFIELD_})
 _HOSTED_({
forthitem
forthcode({OS-IMPORT})
 _HOSTED_LINUX_({
To be able to type shell-commands from within Forth as if you
were in a terminal window.
 })_END_({_HOSTED_LINUX_}).
 _PC_({
To be able to type DOS-commands from within Forth as if you
were in a terminal window.
 })_END_({_PC_}).
 })_END_({_HOSTED_}).
forthendenumerate
 _HOSTED_({
Because this ciforth is ``hosted'', meaning that it is started from
an operating system, you can develop in a convenient way.
Start thisforth in a window, and use a separate window to start your
editor. Try out things in thisforth. If they work, paste the code into
your editor. If a word works, but its source has scrolled off the screen,
you can recover the source using forthcode({CRACK}) .
If you have constructed a part or all of your program,
you can save it from your editor to a file. Then by the command
forthsamp({INCLUDE <file-name> }) load the program in thisforth
and do some further testing.

You are not obliged to work with separate windows.
Suppose your favorite editor
is called _PC_({forthfile({edlin})})_HOSTED_LINUX_({forthfile({vi})}). After

_PC_({forthexample({ "EDLIN" OS-IMPORT EDLIN })})
_HOSTED_LINUX_({forthexample({ "vi" OS-IMPORT vi })})

you can start editing a file in the same way as from
_PC_({a DOS window or plain DOS}) _HOSTED_LINUX_({the shell}).
Of course you now have to switch between editing a file
and thisforth. But at least you need not set up your Forth again,
until your testing causes your Forth to crash.
 })_END_({_HOSTED_})

@subsection Finding things out.
If you want to find things out
you must
start up thisforth again by forthsamp({thisforth -e}).
The sequence
forthexample(
{REQUIRE TUCK
LOCATE TUCK})
shows you the source for TUCK if it is in the library somewhere.
forthexample(
{REQUIRE TUCK
CRACK TUCK})
show you the source for TUCK if it is in the library or in the kernel,
but without comment or usage information.

@section Configuring
For configuring your thisforth, without enlarging the dictionary,
you may use the following sequence
forthexample({ S" myforth.lab" BLOCK-FILE $! \ Or any config
1 LOAD
REQUIRE SAVE-SYSTEM
: DOIT
    'CONTAINS 'FORTH FORGET-VOC
    'CONTAINS >NFA @ DP !
    "newforth" SAVE-SYSTEM BYE ;
DOIT })
Here forthvar({DOIT}) trims the dictionary just before the saving your system into a new
file.
You can use a similar sequence for expanding the system without
building in the forthcode({SAVE-SYSTEM}) command as well.

forthcode({FAR-DP}) allows have a disposable part of the
dictionary. This may be occasionally useful, but make sure to
forthcode({FORGET}) always the disposed off words.


@section Concepts

A forth user is well aware of how the memory of his
computer is organised. He allocates it for certain purposes,
and frees it again at will.

The last-in first-out buffer that remembers data for us is called
the forthdefi({data stack}) or sometimes forthdefi({computation stack}).
There are other stacks around,
but if there is no confusion it is often called just the forthdefi({stack}).
Every stack is in fact a buffer and needs also a forthdefi({stack pointer})dnl
to keep track of how far it has been filled.
It is just the address where the last data item has been stored in the buffer.

The forthdefi({dictionary}) is the part of the memory where the forthdefin({word})'s are
(forthpxref({DICTIONARY})).
Each word owns a part of the dictionary, starting with its name and
ending where the name of the next word starts.
This structure is called a forthdefi({dictionary entry}).
Its address is called a forthdefi({dictionary entry address})dnl
or forthdefi({DEA}). In ciforth's this address is used for external
reference in a consistent way. For example it is used as the
forthdefi({execution token}) of a word in the ISO sense.
In building a word the boundary between the dictionary and the free space shifts up.
This process is called forthdefi({allocating}), and the boundary is marked by
a forthdefi({dictionary pointer}) called forthcode({DP}) .
A word can be executed by typing its name.
Each word in the dictionary belongs to precisely one forthdefi({word list}),
or as we will say here vocabulary.
Apart from the name, a word contains data and executable code,
(interpreted or not) and linking information
(forthpxref({VOCABULARY})).

The concept word list is part of the ISO standard, but we will
use forthdefi({vocabulary}). A vocabulary is much more
convenient, being a word list with a name, created by
forthcode({VOCABULARY}) . ISO merely knows
forthdefi({word list identifier}) 's, a kind of handle,
abbreviated as forthdefi({WID}). A new word list is
created by the use of forthcode({VOCABULARY}), and
by executing the vocabulary word the associated
word list is pushed
to the front of the search order.
In fact in ciforth's every DEA can serve as a WID. It defines a
wordlist consisting of itself and all earlier words in the same
vocabulary.
If needed you can
always derive the WID from the DEA of a vocabulary.

A word that is defined using forthcode({:}) is often called a
forthdefi({colon definition}). Its code is called
forthdefi({high level}) code.

A high level word, one defined by forthcode({:}) , is little more than a
sequence of addresses of other words. The forthdefi({inner interpreter})dnl
takes care to execute these words in order.
It acts by fetching the address pointed by forthvar({HIP}) , storing
this value in register forthvar({W}). It then jumps to the address
pointed to by the address pointed to by forthvar({W}). forthvar({W}) dnl
points to the code field of a definition which contains the address of
the code which executes for that definition. This usage of indirect
threaded code is a major contributor to the power, portability, and
extensibility of Forth.

If the inner interpreter must execute another high level word,
while it is interpreting, it must remember the old value of
forthvar({HIP}), and this so called forthdefi({nesting}) could go several
levels deep.
Keeping this on the data stack would interfere with the data the
words are expecting, so they are kept on a separate stack, the
forthdefi({return stack}).
The usage of two stacks is another hall mark of Forth.

A word that generates a new entry in the dictionary is called a
forthdefi({defining word}) (forthpxref({DEFINING})).
The new word is created in the forthcode({CURRENT}) word list .

Each processor has a natural size for the information. (This is
sometimes called a machine word). For an Pentium processor this is
32 bit, for the older Intel 8086 it is 16 bit.
The pendant in Forth is called a forthdefi({cell}) and its size
may deviate from the processor you are running on.
For this ciforth it is _BITS_,
It applies to the data remembered in the data stack, the
return addresses on the return stack,
memory accesses forthcode({@@}) and forthcode({!}) , the size of forthcode({VARIABLE})' s
and forthcode({CONSTANT})' s.
In Forth a cell has no hair. It is interpreted by you as a
signed integer, a bit-map, a memory address or an unsigned number.
The operator forthcode({+}) can be used to add numbers, to set a bit in
a bitmap or advance a pointer a couple of bytes.
In accordance with this there are no errors such as overflow given.

Sometimes we use data of two cells, a forthdefi({double}).
The high-order cell are most accessible on the stack and if stored in
memory, it is highest.

The code for a high level word can be typed in from the
terminal, but it can also fed into Forth by redirection from a
file, forthcode({INCLUDED}) from a file or you can
forthdefi({load}) it from the file forthfile({forth.lab}),
because you can load a piece of this library at will once you
know the block number. This file is divided into
forthdefi({blocks}) of 1 Kbyte. They may contain any data, but
a most important application is containing source code. A block
contain source code is called a forthdefi({screen}). It
consists of 16 lines of 64 characters. In ciforth the 64-th
character is forthkey(^J) such that they may be edited in a
normal way with some editors. To forthdefi({load}) such a
screen has the same effect as typing its content from the
terminal.
The extension lab stands for forthdefi({Library Addressable by Block}),

Traditionally Forthers have things called
forthdefi({number})'s, words that are present in the source be
it interpreted or compiled, and are thought of not as being
executed but rather being a description of something to be put
on the stack directly. In early implementations the word forthsamp({NUMBER})
was a catch-all for anything not found in the dictionary, and
could be adapted to the application.
For such an extensible language as
Forth, and in particular where strings and floating point
numbers play an increasing role, numbers must be generalised to
the concept of forthdefi({denotation})'s.
The need for a way to
catch those is as present as it was in those early days.
Denotations put a
constant object on the stack without the need to define it
first. Naturally they look, and in fact are, the same in both
modes. Here we adopt a practice of selecting a type of the denotations
based on the first letter. This is quite practical and familiar.
Examples of this are (some from C, some from assemblers, some
from this Forth) :
forthexample({10
'a'
^A
0DEAD
$8000403A
#3487
0177
"Arpeggio"
"JAMES BROWN IS DEAD"
" JK "
'DROP
' DROP})
These examples demonstrate
that a denotation may contain spaces, and still are easy to scan.
And yes, I insist that forthsamp({' DROP}) is a denotation.
But forthsamp({'DROP}) is clearer,
because it can only be interpreted as such;
it is not a valid word.

Of course a sensible programmer will not define a word that looks like
a denotation :
forthexample({ : 7 CR "This must be my lucky day" TYPE ; ( DON'T DO THIS) })
@section Portability
If you build your words from the words defined in the ISO standard,
and are otherwise careful, your programs may run on other systems that
are ISO standard.

There are no gratuitous deviations from the standard.
However a few things are not quite conforming.
forthenumerate
forthitem
The error system uses forthcode({CATCH}) and forthcode({THROW}) in a conforming way.
However the codes are not assigned according to the table
in the standard. Instead positive numbers are ciforth errors
and documented in this manual.
ciforth's errors identify a problem more precisely than the
standard allows. An error condition that is not detected
has no number assigned to it.
Negative numbers are identical
to the numbers used by the host operating system.
No attempt is made to do better than reproduce the messages
belonging to the number _HOSTED_LINUX_({as given by strerror.}) _PC_({stated
in Ralph Browns list, which is slightly better than the MSDOS
programmers Manual.})
forthitem
It is not possible to catch the following words :
forthcode({ABORT"}) forthcode({ABORT}) forthcode({QUIT}) .
forthitem
There is no forthcode({REFILL}) . This is a matter of
philosophy in the background. You may not notice it.
forthbreak
Consequences are that forthcode({BLK}) is not inspected for every
word interpreted, but that blocks in use are locked.
Files are not read line by line, but read in full and
evaluated.
_CIF_IN_({
forthitem
It doesn't use forthcode({>IN}) exactly in the way prescribed by ISO.
The forthcode({>IN}) that is there is a fake, that can only be
read, not changed.
}) dnl
forthitem
Vocabularies are wordlists with a name. However they push the wordlist
to the search order, instead of replacing the topmost one.
In this sense forthcode({FORTH}) and forthcode({ASSEMBLER}) words are not
strictly conforming.
forthitem
This is not strictly non-conforming, but worth mentioning here.
In fact thisforth contains only one state-smart word
besides forthcode({SLITERAL}) (that word is forthcode({."}) ).
All denotations are state-smart,
but the result is correct ISO behaviour for numbers.
Knowledge of this is used freely in the libraries of ciforth;
it is the right of a system developer to do so.
The library is not a supposedly ISO-conforming program.
It tends to rely on
ciforth-specific and thisforth-specific -- but hopefully documented -- behaviour.
Understanding it requires some study of non-portable facilities.
forthendenumerate

Here we will explain how you must read the glossary of thisforth,
in relation to terminology in the ISO standard.

Whenever the glossary specifies under which conditions a word may
 forthdefi({crash}), then you will see the euphemism forthdefi({ambiguous condition}) in
the ISO standard.

For example:
forthbreak
Using forthcodeni({HOLD}) other than between
forthcodeni({<#}) and forthcodeni({#>}) leads to a crash.

Whenever we explicitly mention ciforth in a sentence that appears
in a glossary entry,
the behaviour may not apply to other ISO standard systems.
This is called forthdefi({ciforth specific behaviour}). dnl
If it mentions ``this ciforth'' or ``thisforth'', you cannot even trust that
behaviour to be the same on other ciforth systems.
Often this is called an ``implementation defined'' behaviour in the standard.
Indeed we are obliged to specify this behaviour in our glossary,
or we don't comply to the standard.
The behaviour of the other system may very well be a crash.
In that case the standard probably declares this an ``ambiguous condition''.

For example:
forthbreak
On this ciforth forthcodeni({OUT}) is set to zero whenever forthcodeni({CR}) is executed.

The bottom line is that you never want to write code where
thisforth may crash.
And that if you want your code to run on some other system,
you do not want to rely on forthdefi({ciforth specific behaviour}).
If you couldn't get around that,
you must keep the specific code separate.
That part has to be checked carefully against the documentation
of any other system,
where you want your code to run on.

By using forthcode({CELL+}) it is easy to keep your code 16/32 bit clean.
This means that it runs on 16 and 32 bits systems.
@section Saving a new system
We have said it before: ``Programming Forth is extending the Forth language.''.
A facility to save your system after it has been extended is of the essential.
It can be argued that if you don't have that, you ain't have no Forth.
It is used for two purposes, that are in fact the same.
Make a customised Forth, like forthemph({you}) want to have it.
Make a customised environment, like a customer wants to have it.
Such a ``customised environment'', for example a game, is often
called a forthdefi({turnkey system}) in Forth parlance.
It hides the normal working of the underlying Forth.
_HOSTED_({
In fact this is what in other languages would be called ``just compiling'',
but compiling in Forth means adding definitions to an interactive Forth.
In ciforth ``just compiling'' is as easy as in any language
(forthpxref({Manual}), Hello world!).})
Of course, whether you have a
hosted system _HOSTED_LINUX_(like this one) _HOSTED_MSDOS_(like this one) or
a booted system _BOOTED_(like this one), it is clear that some
system-dependant information goes into accomplishing this.

This has all been sorted out for you. Just use
forthcode({SAVE-SYSTEM}) .
This accepts a string, the name you want the
program-file to have.

In the following it is explained.
We use the naming convention of ISO about cells.
A cell is the fundamental unit of storage for the Forth engine.
Here it is _BITS_ bits (_BITS16_(2)_BITS32_(4) bytes).

The change of the boot-up parameters at
forthcode({+ORIGIN}), in combination with storing an image on disk
goes a long way to extending the system.
This proceeds as follows:
forthenumerate
forthitem
All user variables are saved by copying them from forthsamp({U0 @@})
to forthsamp({0 +ORIGIN}).
The user variable forthcode({U0}) dnl
points to the start of the user area. The length of the area is M4_US cells.
If in doubt check out the variable forthvar({US}) in the assembler code.
forthitem
If all user variables are to be initialised to what they are in this live system
skip the next step.
forthitem
Adjust any variables to what you want them to be in the
saved system in the forthcode({+ORIGIN}) area.
The initialisation for user variable forthvar({Q}) can be found at
    forthsamp({' Q >DFA @@ +ORIGIN}).
forthitem
Adjust
version information (if needed)
forthitem
Copy your thisforth to a new file using forthcode({PUT-FILE}) .
The difficult part is to add to the system specific header information
about the new size of the system, which is
the area from forthcode({BM}) to forthcode({HERE}).
The command forthsamp({REQUIRE SAVE-SYSTEM}) loads
a version that does that correctly for your hosted system.
forthendenumerate

@section Memory organization

A running ciforth has 3 distinct memory areas.

They occur sequentially from low memory to high.
forthitemize
forthitem
The dictionary
forthitem
Free memory, available for dictionary, from below, and stacks, from above
forthitem
Stacks{}_HIGH_BUF_({, disk block buffers}) and terminal
input buffer.
forthenditemize
The lowest part of the free memory is used as a scratch area.

_LOW_BUF_({The disk block buffers are allocated in the dictionary,
because otherwise they would not be accessible to the BIOS})

The program as residing on disk may contain startup code, but that is
of no concern for the usage.

The dictionary area is the only part that is initialised,
the other parts are just allocated.
Logically the Forth system consists of these 7 parts.
forthitemize
forthitem
Boot-up parameters
forthitem
Machine code definitions
forthitem
Installation dependant code
forthitem
High level standard definitions
forthitem
High level user definitions
forthitem
System tools (optional)
forthitem
RAM memory workspace
forthenditemize

@subsection Boot-up Parameters

The boot-up area contains initial
values for the registers needed for the Forth engine,
like stack pointers, the pointers to the special memory area's,
and the very important dictionary pointer forthcode({DP})dnl
that determines the boundary between the dictionary and free space.

Instead they are copied to a separate area the forthdefi({user area}) ,
each time Forth is started.
The bootup area itself is not changed, but the variables in the user
area are.
By having several user area's, and switching between them,
ciforth could support multitasking.
When you have made extensions to your system, like for instance you
have loaded an editor, you can make these permanent by updating the
initial values in the boot-area and saving the result to disk as an
executable program.
The boot-up parameters
extends from forthsamp({0 +ORIGIN}) and has initial value for all
of the user area.
This is the image for the forthdefi({user area}).
_SUPPRESSED({ It is not quite clear whether this will be restored.
Presently it is not present.
It also extends 6 cells downwards, containing machine code for two
jumps, to the warm and the cold start, and a version number.})
So in ciforth the bootup parameters are more or less the data field of the
forthcode({+ORIGIN}) word.
Executing forthsamp({0 +ORIGIN}) leaves a pointer in this area.
_SUPPRESSED({but after the jump vectors and the release numbers.})

@subsection                     Installation Dependent Code

forthcode({KEY}) forthcode({EMIT}) forthcode({KEY?}) forthcode({CR}) and
forthcode({R/W}) are indeed different for different I/O models.
This is of little concern to you as a user,
because these are perfectly normal dictionary entries and the different
implementations serves to make them behave similarly.
There will however be more differences between the different configurations for
ciforth for these words than habitually.

@subsection                      Machine Code Definitions

The machine executable code definitions
play an important role because they
convert your computer into a standard Forth stack computer.
It is clear that although you can define words by other words,
you will hit a lowest level.
The forthdefi({code word})'s as these lowest level programs are called,
execute machine code directly, if you invoke them from
the terminal or from some other definition.
The other definitions, called forthdefi({high level}) code,
ultimately execute a sequence of the machine executable code words.
The Forth forthdefi({inner interpreter}) takes care that
these code words are executed in turn.

In the assembler source (if you care to look at it)
you will see that they are interspersed with the
high level Forth definitions.
In fact it is quite common to decide to rewrite a code definition in high level
Forth, or the other way around.

Again code words are perfectly normal dictionary entries.
@subsection                      High-level Standard Definitions

The high level standard definitions add all
the colon-definitions, user variables, constants, and variables that
must be available in a
"Forth stack computer" according to the ISO standard.
They comprise the bulk of
the system, enabling you to execute and compile from the terminal,
execute and
forthdefi({load}) code from disk to add definitions
etc.
Changes here will result in deviations from the standard,
so you probably want to leave this area alone.
Again these words are perfectly normal dictionary entries.
_VERBOSE_({The technique described for the next section,
forget and recompile,
is not always possible here because of circular references.
That is in fact no problem with an assembler listing,
but it is if you load Forth code.})

Again standard definitions words are perfectly normal dictionary entries.
@subsection                    User definitions

The user definitions
contain primarily definitions involving user interaction:
compiling aids, finding, forgetting, listing, and number formating.
Some of these are fixed by the ISO standard too.
These definitions are placed above the standard definitions to
facilitate modification.
That is you may forthcode({FORGET}) part of
the high-level and re-compile altered definitions from disc.
This applies even to the ISO standard words from the
forthvar({TOOLS}) wordset like forthcode({DUMP}) (show a memory area as
numbers and text) and forthcode({.S}) (show the data stack).

Again these words are perfectly normal dictionary entries.
_LOAD_({A number of entries that could easily be made loadable
are integrated in the assembler source of this ciforth version.})
You can forget them, and load your own version from files or blocks.

Again user definitions words are perfectly normal dictionary entries.
@subsection                    System Tools

The boundary between categories are vague. A system tools is
contrary to a user tool, a larger set of cooperating words.
A text editor and machine code assembler are the first tools
normally available.
An assembler is
not part of ciforth as delivered, but it
is available after forthsamp({REQUIRE ASSEMBLERi86}).
It automatically loads the proper _BITS_-bits version.
You can load a more elaborate assembler. forthxref(Assembler) Section Overview.
They are among the first candidates to be integrated into
your system by forthcode({SAVE-SYSTEM}) .
_PC_({ We are including a sample editor, that is quite handy})
_HOSTED_LINUX_({An editor is not part of ciforth as delivered.
Development in Linux uses the there available editors.
Even without tools, code can be
tested by piping it into Forth, then commanding Forth to
look to the console, as follows :
forthbreak
forthsamp({ (echo 8 LOAD; cat pascal.frt - )| thisforth })
forthbreak
Primitive and preliminary as this may seem,
it has been used for quite substantial developments like the
80386 assembler.
forthbreak
More advanced is using Your Favorite Editor, followed by
including files:
forthbreak
forthsamp({ "vim mysrc.frt" SYSTEM })
forthbreak
forthsamp({ "mysrc.frt" INCLUDED })
forthbreak
})forthxref(Manual) Section Getting Started.

386 and a 8086
Forth assemblers are available in forthfile({forth.lab}).
They are loaded in accordance with the system that is run.

It is essential that you regard thisforth as just a way to get started
with Forth.
Forth is an extensible language, and you can set it to your hand.
But that also means that you must not hesitate to throw
away parts of the system you don't like, and rebuilt them
even in conflict with standards.
_VERBOSE_(
{Additions and changes must be planned and
tested at the usual Forth high level.
Later you can rewrite them as code words.})

Again words belonging to tools are perfectly normal dictionary entries.
@subsection                    RAM Workspace
The RAM workspace contains the compilation space for the dictionary,
_HIGH_BUF_({disc buffers,}) the computation and return stacks, the user area,
and the terminal input buffer,
_VERBOSE_({From the figforth user manual
forthquotation
For a single user system, at least 2k bytes must be available above the
compiled system (the dictionary). A 16k byte total system is most typical.
forthendquotation})
It is indeed possible to do useful work,
like factoring numbers of a few hundred digits, in a workspace of 2k bytes.
More typical a workspace is several megabytes to over hundred megabytes.

_BITS16_({There is no longer a reason to put up with a 16-bit system less than 64K.})
_BITS32_({32 bits system are set at 64Mbyte but this is arbitrary and could be set much
higher or lower without consequences for system load or whatever.
Before long we will put the dictionary space on I86-Linux to 4G minus
something and forget about this issue forver. })

_VERBOSE_(
{The boundary between this area and the previous one is pretty sharp,
it is where forthcode({DP}) points.
The other areas are not clearly separated at all.
But even this boundary constantly changes as you add and forget definitions.})
@section Specific layouts
@subsection The layout of a dictionary entry

We will divide the dictionary in entries.
A forthdefi({dictionary entry}) is a part of the dictionary that
belongs to a specific word.
A forthdefi({dictionary entry address}), abbreviated
forthdefi({DEA}) is a pointer to the header of
a dictionary entry.
In
ciforth a header extends from the lowest address of the entry, where the code
field is to the forthdefi({past header address}), just after the last field address.
A forthdefin({dictionary entry}) apart from the header owns a part of
the dictionary space that can extend before the header (mostly the
name of the entry) or after it (mostly data and code).

A dictionary entry has fields, and the addresses of fields directly
offset from the dictionary entry address, are called
forthdefi({field address}). This is a bit strange terminology, but
it makes a distinction between those addresses and other addresses.
For example, this allows to make the distinction between a
forthdefi({data field address}), that is always present, and a
forthdefi({data field}) in the ISO sense that has only a
(differing) meaning for
forthcode({CREATE}) forthcode({DOES> }) definitions.
Typically, a field address contains a pointer. A
forthdefi({data field address}) contains a pointer to
near the forthdefi({data field}), whenever the latter exists.

They go from lowest in memory to highest:
forthenumerate
forthitem
The code field. This is one cell.
A pointer to such a field is called a forthdefi({code field address}).
It contains the address of the code to be executed for this word.
forthitem
The data field, of the DEA, not in the ISO sense.
This is one cell.
A pointer to such a field is called a forthdefi({data field address}).
It contains a pointer to an area owned by this definition.
forthitem
The flag field. This is one cell.
A pointer to such a field is called a forthdefi({flag field address}).
For the meaning of the bits of the flag field sea below.
forthitem
The link field. This is one cell.
A pointer to such a field is called a forthdefi({link field address}).
It contains the
dictionary entry address of the last word that was
defined in the same forthdefi({word list}) before this one.
forthitem
The name field. This is one cell.
This contains a pointer to a string.
A pointer to such a field is called a forthdefi({name field address}).
The name itself is stored outside of the dictionary header
in a regular string, i.e. a one cell count followed by as many characters.
_VERBOSE_({Unfortunately, forthdefi({name field address}) is
sometimes used, where a forthdefi({dictionary entry address}) would
be more correct, especially in older documentation.
This came about because the
name was lowest in memory. That they happen to be the same is
no reason to confuse two completely different concepts. In this
Forth the code field address and the dictionary address are the
same, but not accidentally so. })
_SOURCEFIELD_({forthitem
The source field. This is one cell.
This can be used to hold a reference to the source,
a block number or a pointer to a string.
It has not been filled in, in the kernel system.},{dnl})
forthitem
Past the header . This is actually not a field, but the
free roaming dictionary. However, most of the time the part of
the dictionary space owned by a dictionary entry starts here. A
pointer to such a field is called a forthdefi({past header
address}).
Mostly a forthdefi({data field address}) contains a
pointer to just this address.
forthendenumerate

Note that the entries are not only in alphabetic order, they
are in order of essentiality. They are accessed by
forthcode({>CFA}) forthcode({>DFA}) forthcode({>FFA}) forthcode({>LFA}) forthcode({>NFA}) forthcode({>SFA}) .

Note forthdefi({data field}) has a specific meaning in the ISO
standard. It is accessed through forthcode({>BODY}) from the
forthdefi({execution token}) while a data field address is
accessed through forthcode({>DFA}) from the
forthdefi({dictionary entry address}). It is in fact one cell
behind where the forthdefi({data field address}) pointer points
to.

The most important flag bits currently defined are:
forthitemize
forthitem
The INVISIBLE bit = 1 when forthdefi({smudge})d, and will prevent a
match by forthcode({(FIND)}).
forthitem
The IMMEDIATE bit = 1 for IMMEDIATE definitions; it is called the
 forthdefi({immediate bit}).
forthitem
The DUMMY bit =1 for a dictionary header contained in the
data of a vocabulary. This indicates that it should not be executed.
forthitem
The DENOTATION bit =1 for a prefix word.
This means that it is a short word used as a prefix
that can parse
all forthdefi({denotation})'s (numbers) that start with that prefix, e.g. 7 or & .
Usually it is a one letter word, but not necessarily.
All built-in prefix words are part of the minimum search order.
_ALIGNED_(
{forthitem
After the last letter follow zero bytes up till the next cell boundary.})
forthenditemize
forthcode({(CREATE)}) takes care to generate this data structure;
it is called by all defining words.

For all forthdefi({colon definition})'s the code field contains
a pointer to the same code, the forthdefi({inner interpreter}), called
forthsamp({DOCOL}).
For all words defined via forthsamp({CREATE ... DOES>}) the code field
contains the same code, forthsamp({DODOES}).

At the forthdefi({data field address}) we find a pointer to an area with a
length and content that depends on the type of the word.
forthitemize
forthitem
For a code word, it contains machine code.
The code field of this word points to it too.
forthitem
For a word defined by
forthcode({VARIABLE}), forthcode({USER}), or forthcode({CONSTANT}) dnl
it has a width of one cell, and contains data.
forthitem
For all forthdefi({colon definition})'s the data field address
contains a pointer to an area with a variable length. It contains the
compiled high level code, a sequence of forthdefi({code field
address})es.
forthitem
For a word defined via forthsamp({CREATE ... DOES>}) the first
cell of this area contains a pointer to the
forthdefi({high level}) code defined by forthcode({DOES>}) and the remainder is
data. A pointer to the data is passed to this
forthcode({DOES>}) code.
forthenditemize

A forthdefi({dictionary entry address}) can be turned into any
of these fields by words that are in the vocabulary
forthsamp({DICTIONARY}). forthxref({DICTIONARY}), for those field words. They
customarily start with forthkey({>}).

A dictionary falls apart into the
forthenumerate
forthitem
Headers, with their fields.
forthitem
Names, pointed to by some forthdefi({name field address}).
forthitem
Data, pointed to by some forthdefi({data field address}).
This includes high level code, that is merely data fed into
the high level interpreter.
forthitem
Code, pointed to by some forthdefi({code field address}).
This is directly executable machine code.
forthendenumerate
@subsection Details of memory layout

The disc buffers are mainly needed for source code that is fetched
from disk were it resides in a file.
_HIGH_BUF_({
The disc buffer area is at the upper bound of RAM memory, So it ends at forthcode({EM}) . })
_LOW_BUF_({
The disc buffer area is in fact the data area owned by forthcode({FIRST}). })
It is comprised of
an integral number of buffers, each forthcode({B/BUF}) bytes plus two cells.
forthcode({B/BUF}) is the number of bytes read from the disc in one go{}_VERBOSE_({,
originally thought of as one sector}).
In ciforth's forthcode({B/BUF}) is always the size of one screen according to ISO :
1024 bytes.
The constant forthcode({FIRST}) has the value of the address of the start of the first
buffer.
 forthcode({LIMIT}) has the value of the first address beyond the top buffer.
The distance between forthcode({FIRST}) and forthcode({LIMIT}) is a multiple of
forthcode({B/BUF CELL+ CELL+}) bytes.

For this ciforth the number of disk buffers is configured
at M4_NBUF . The minimum possible is approximately 8 because nesting and locking
requires that much blocks available at the same time.

The user area is configured to contain M4_US cells, most of it unused.
User variables can be added by the word forthcode({USER}) , but you have
to keep track yourself which offset in the user area can be used.
_HIGH_BUF_({ The user area is just under the disc
buffers. So it ends at forthcode({FIRST}) . }) _LOW_BUF_({ The
user area is at the upper bound of RAM memory. So it ends at
forthcode({EM}) . })

The terminal input buffer  and the return stack share an area configured at a
size of M4_RTS bytes.
The lower half is intended for the terminal input buffer, and the higher part
is used for the return stack, growing down from the end.
The initial stack pointer is in variable forthcode({R0}).
The return stack grows downward from the user area toward the terminal
buffer.

The computation stack grows downward from the terminal buffer toward the
dictionary which grows upward.
The initial stack pointer is in variable forthcode({S0}).

During a cold start, the user variables are initialised from the bootup parameters
to contain the addresses of the above memory assignments.
_VERBOSE_({
They can be changed.
forthxref({+ORIGIN}) for the bootup area.
But take care. You probably need to study the source for how and when they
take effect.})

_VERBOSE_( {If you need multi-tasking you have to allocate a
separate user area for each task, as well as a separate return
stack area and a separate data stack area. A task that asks for
input, also needs an extra terminal input buffer.})
@subsection  Terminal I/O and vectoring.
It is useful to be able to change the behaviour of I/O words such
that they put their output to a different channel.
For instance they must output to the
printer instead of to the console.
In general this is called forthdefi({vectoring}).
Remember that in normal Forth system,
all printing of numbers is to the terminal,
not to a file or even a buffer.
 _HOSTED_LINUX_({(On a linux system something like it
can be accomplished
by the redirection facilities available.)})
_HOSTED_MSDOS_({(On a MSDOS system the need for this should be low,
because of the redirection facilities available.
However they are buggy.)})
_BOOTED_({(On a standalone system the need for this is high,
because there is no redirection.)})
For this reason character output forthcode({CR}), forthcode({EMIT}) and
forthcode({TYPE}) all go through a common word that can be changed.
_LINUX_N_({For thisforth it is forthcode({TYPE}) }).
Because this is defined in high level code it can temporarily be replaced
by other code. This forthdefi({revectoring}) is possible for all high level
words in ciforth,
such that we need no special measures to make forthdefi({vectoring}) possible.
As an example we replace forthcode({TYPE}) by forthcode({MYTYPE}) .
forthbreak forthsamp({' MYTYPE >DFA @ ' TYPE >DFA !}) forthbreak
And back to default:
forthbreak forthsamp({' TYPE >PHA ' TYPE >DFA !}) forthbreak
Be careful not to define forthcode({MYTYPE}) in terms of forthcode({TYPE}) , as a
recursive tangle will result.
This method works in all versions of ciforth and is called forthdefi({revectoring}).

A similar technique is not so useful on the input side,
because keys entered during forthcode({EXPECT}) are subject to correction
until <RET> has been pressed.
_HOSTED_LINUX_({On thisforth forthcode({EXPECT}) is left to the
operating system, such that inputting to thisforth has the same
look and feel as other input.
Text can be pasted in with the mouse, etc.
Consequently forthcode({RUBOUT}) is not used.
})

@section Libraries and options

In ciforth there is no notion of object (i.e. compiled) libraries,
only of source libraries.
A Forth forthdefi({library}) is a block file adorned with one convention.
This is that the words defined in a screen are
mentioned on the first line of that screen,
the forthdefi({index line}).
This is of course quite established as a habit.
The word forthcode({REQUIRED}) takes a string and loads the
first screen where that name occurs in the index line. For
convenience also forthcode({REQUIRE}) is there that looks ahead
in the input stream.
These words are not in the kernel but are in screen 17, that
corresponds to the forthsamp({-r}) option.

Screen 0 and screen 1 to 31 are reserved.
_HOSTED_({
When a Forth is started up with
a first parameter that is a one-letter option, the corresponding
screen is to be executed. _VERBOSE_({So forthsamp({-a}) or forthsamp({-A}) is
equivalent to forthsamp({1 LOAD}) and forthsamp({-z}) or
 forthsamp({-Z}) is equivalent to forthsamp({26 LOAD}).})
 _VERBOSE_({{In fact all options are mapped onto screen 0..31 by a bitwise and.}})
@subsection Options
ciforth is a primitive system, and can interpret just one option on the
command line. If the first argument is not starting with forthkey({-}) _PC_({or forthkey({/})})
ciforth returns with error code 3.
However the option forthsamp({-l}) can bootstrap it into
more sophisticated behaviour.

The following options can be passed to thisforth on the command line:

forthitemize

forthitem
forthsamp({-a})

Make sure forthcode({REQUIRED}) is available.
This is a copy of the forthsamp({-r}) command
because it is easier to remember forthsamp({1 LOAD}) if the screen
must be loaded manually.
In addition the signon message is suppressed.

forthitem
forthsamp({-c name})

Compile the file forthfile({name}) to an executable binary. The name of the binary
is forthfile({name}) without the trailing forthsamp({.frt}) or else forthfile({a.out}).
Upon invocation of the binary the word defined latest is executed, then Forth goes
 forthcode({BYE}) .
_VERBOSE_({ forthfile({name}) {is a regular source file, not a block file.}})
Also forthcode({REQUIRED}) is made available.

forthitem
forthsamp({-e})

Load the elective screen, screen 5. This contains forthdefi({preferences}),
the tools you want to have available running an interactive Forth.
The  default library file contans system wide default preferences.
See the forthsamp({-l}) option if the default preferences don't suite you.
_VERBOSE_({{In a elective screen you just put
commands you want to be executed after Forth starts up, such as }})
_VERBOSE_({forthsamp({ "fortune -f /usr/lib/forthcookies" SYSTEM })})
_VERBOSE_({{ or }})
_VERBOSE_({forthsamp({ REQUIRE EDIT })})

forthitem
forthsamp({-f forthcode})

Execute the forthsamp({forthcode}) in the order present.
_VERBOSE_({{Beware of the special characters in the shell. Also
the shell will collapse multiple spaces into one.}})

forthitem
forthsamp({-g number name})

Expand the system by forthsamp({number}) Megabytes, then save it
under the name forthsamp({name}).
forthsamp({number}) may be negative, and in that case the system
is made smaller.

forthitem
forthsamp({-h})

Print overview of options.

forthitem
forthsamp({-i binpath libpath [shellpath]})

Install the forth in forthsamp({binpath}) and the library in forthsamp({libpath}) .
If the forthsamp({shellpath}) parameter is specified,
it will be installed as the command interpreter used for forthcode({SYSTEM}).
All of them must be full path names, not just directories.
The ciforth that is running is copied to forthfile({binpath}), and the block file
is copied to forthfile({libpath}).

_HOSTED_LINUX_({
For system wide installation on a modern large system the following
is recommended:
forthexample({
    su
    ./lina -g 60 lina+
    ./lina+ -i /usr/bin/lina /usr/lib/forth.lab
    chmod 755 /usr/bin/lina
    chmod 644 /usr/lib/forth.lab})

For a smallish system you may expand by 0 Mbyte forthsamp({-g 0}).
If the system has no swap space, and less than 8 Mbyte of memory,
use forthsamp({-g -3}), diminish from 4 to 1 Mbyte.

})
_HOSTED_LINUX_({
forthitem
forthsamp({--help})
forthsamp({--version})
forthsamp({--})
forthsamp({-m})

In ciforth all options are mapped onto a letter. All options
that start with forthkey({-}) are mapped onto forthkey({m}).
The result is the combination of -h and -v , so both help and
version information is printed.
_VERBOSE_({This conforms to the FSF-conventions.})
})
forthitem
forthsamp({-l name [more]})

Use a library forthsamp({name}).
Restart Forth with as a block file forthfile({name}) and as options the remainder
of the line shifted, such that
forthsamp({-l name}) disappears and the next option becomes the first.
A file specified via forthsamp({-l}) is opened for reading and
writing.
Options ara again handled as as described in the begining of this section.
In this way options may be added or reconfigured for personal use.

Note that the default file is opened for reading only.

_SUPPRESSED({ It is not clear whether we really want this. It will mostly be
part of -e anyway, and makes little sense otherwise. Or maybe for scripting?
forthitem
forthsamp({-o})

Import operating system commands. Some often used commands like
forthsamp({ls more cat cd echo make }) can be typed to Forth as if it where a shell.
forthcode({OS-IMPORT}) is made available to add to this list.
})

forthitem
forthsamp({-r})

Make sure forthcode({REQUIRED}) is available.

_HOSTED_LINUX_({
forthitem
forthsamp({-s script})

Load the file forthfile({script}) , but ignore its first line.
This is intended to be used for scripts, i.e. a piece of code to be
interpreted rather than compiled.
_VERBOSE_({{The first line is probably}
forthsamp({#!lina -s}){ or some such as }
forthsamp({#!lina -l /usr/lib/forth/cgi/forth.lab -s}).})
In a script forthcode({REQUIRED}) is available and
you can use standard in and standard out.
})
forthitem
forthsamp({-t sourcefile})

Try to load the file forthfile({script}) automatically, by possibly unsafe means.
Report facilities that were required.
This is a first step in a porting activity.
_VERBOSE_({Redefinition messages are issued on the error channel that
can be redirected to /dev/nul leaving the report.})

forthitem
forthsamp({-v})

Print version and copy right information.

forthenditemize

The remaining screens are available for options to be added at a later time,
or for user defined options in a private library.
})_END_({_HOSTED_})
@subsection Private libraries

Working with source in files is quite comfortable using the default block library, especially
if sufficient tools have been added to it. In principle all ISO words should be
made available via forthcode({REQUIRED}) .

In order to customize the forth library, you have to make a
copy _HOSTED_LINUX_({of the default
forthfile({/usr/lib/ciforth/forth.lab}) to your home directory}), preferably to a lib
subdirectory.
Then you can start up using a forthsamp({-l}) option, or make a customized thisforth.
forthxref(Manual) Subsection Configuring.

_HOSTED_LINUX_({
Most shells allow you to redefine commands, such as e.g. in bash:
forthbreak alias lina='lina -l $HOME/lib/forth.lab' forthbreak
})
_HOSTED_DPMI_({You can make a pif file that start forthsamp({wina}) with
a library:
forthbreak wina -l c:/projects/database/forth.lab. forthbreak
})
_HOSTED_MSDOS_({You can make a forthvar({.BAT}) file that start forthsamp({mina}) with
a library :
forthbreak mina -l c:/projects/database/forth.lab %1 %2 forthbreak
})

Note that the forthsamp({-l}) option hides itself, such that
such an alias can be used completely identical to the original
with respect to all options, including forthsamp({-l}).
Analysing arguments passed to thisforth in your programs can remain
the same.

@subsection Turnkey applications.
Turnkey application are made using the word forthcode({TURNKEY}) .
They take a word, that is to be done, and a string with the file name.
Mostly it is much easier to just use the forthsamp({-c}) option.
forthxref(Manual) Getting Started Subsection Hello World!
A turnkey application should decide what to do with the library file that is default
opened in forthcode({COLD}) . Make sure to forthcode({CATCH}) errors from
forthcode({BLOCK-EXIT}) and ignore them.
dnl This was the former philosophy: (is it better?)
dnl Errors from BLOCK-EXIT never lead to throws and can be safely ignored.
